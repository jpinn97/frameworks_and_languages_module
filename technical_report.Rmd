---
title: "Technical Report"
output:
  pdf_document:
    citation_package: default
  md_document:
    variant: gfm
bibliography: bibliography.bib
csl: harvard-cite-them-right.csl
link-citations: true
---

`r if (knitr::is_html_output()) "# Technical Report"`

The purpose of this report is to evaluate and critique the current
framework-less example server and client prototype, and justify and
describe an implementation that includes frameworks and specific
language features. For a simple CRUD (Create, Read, Update, Delete)
Single Page Application (SPA), the usage of frameworks and specific
languages are a necessity for the development of a commercial
application.

Building from scratch may offer complete control over every aspect of
the application if our application was highly unique, but we needn't
reinvent the wheel. Well-established frameworks generally have large
communities, and thus have a wealth of resources, documentation, and
support in addition to thoroughly tested and community driven features.
Which will enable us to develop faster, and maintain our application
more easily over the long term.

## Critique of Server/Client prototype

### Overview

Commercial applications typically require a server to be scalable,
maintainable, and optimized for performance. Hand-rolling solutions
commonly found in frameworks can lead to challenges in development as
application complexity grows, which occurs as new features are added and
extended to improve customer experience.

This stacks up technical debt, it's easier to hire developers who are
familiar with frameworks than it's to hire and train developers with a
custom in-house solution.

### Issue 1

The server is not scalable or capable of asynchronous or concurrent
operations.

Function Reference:

-   **Function Name**: `serve_app` \
-   **Located in**: `example_server/app/http_server.py` \
-   **Source Code**: [Link to
    Function](https://github.com/calaldees/frameworks_and_languages_module/blob/f396251252434a5a37f29d1ec684ac31d4644bbb/example_server/app/http_server.py#L99-L134)

``` python
99 . def serve_app(func_app, port, host=''):
100.    with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
101.        s.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
102.        s.bind((host, port))
103.        while True:
104.             s.listen()
105.            try:
106.                conn, addr = s.accept()
107.            except KeyboardInterrupt as ex:
108.                break
109.            with conn:
```

The function `serve_app` is used to listen for incoming connections, and
handle them. On line 104, the function `s.listen()` is called, which
will block the thread until a connection is made. This means that the server will not be able to handle any other requests until the current request is completed. 
Furthermore, according to [@am_i_helpfulAnswerWhatBacklog2016] and [@SocketLowlevelNetworking2023], the backlog size is influenced by the operating system (OS)'s SOMAXCONN, Linux is currently set to 4096 [@NetIncreaseSOMAXCONN2019], the large buffer of unaccepted connections will cause clients to experience latency if the server is under heavy load due to the sequential handling of requests.

``` python
110. #log.debug(f'Connected by ')
111. #while True:
112.     data = conn.recv(65535)  # If the request does not come though in a single recv/packet then this server will fail and will not composit multiple TCP packets. Sometimes the head and the body are sent in sequential packets. This happens when the system switches task under load.
113.     #if not data: break
114.     try:
115.         request = parse_request(data)
116.     except InvalidHTTPRequest as ex:
117.         log.exception("InvalidHTTPRequest")
118.         continue
119. 
120.     # HACK: If we don't have a complete message - try to botch another recv - I feel dirty doing this 
121.     # This probably wont work because utf8 decoded data will have a different content length 
122.     # This needs more testing
123.     while int(request.get('content-length', 0)) > len(request['body']):
124.         request['body'] += conn.recv(65535).decode('utf8')
```

The function struggles with handling TCP data that arrives in fragments, attempting to make additional recv calls to gather more data. It relies on the content-length header to decide if further recv calls are necessary. However, this approach fails to properly decode non-UTF-8 data, such as binary image data. Additionally, UTF-8's variable-width encoding has multibyte characters such as "C3 A9" occupying two bytes and is "Ã©" [@UTF82023] that might be split across different packets which when decoded could form an illegal sequence, leading to a UnicodeDecodeError [@UnicodeDecodeErrorPythonWiki2008]. As indicated in the comments on line 121, the actual body size can become larger than what the content-length suggests as data size increases once decoded. The server will drop the connection if the content-length is exceeded, which will result in a broken image or data corruption.

Finally, the function has no error handling in the case of timeouts or resource exhaustion.

### Issue 2

File Reference:

-   **File Name**: `index.html` \
-   **Location**: `example_client/index.html` \
-   **Description**: The example client. \
-   **Source Code**: [Link to File](https://github.com/calaldees/frameworks_and_languages_module/blob/0f55f66639768032a3f0c0d795e6517ca52f0a11/example_client/index.html)

A number of functions such as `renderItems`, `renderDataToTemplate`, `attachDeleteAction`, and `clear_node` directly manipulate the DOM. This is generally not recommended to do in such vast amounts. Especially when the functions are tightly coupled.

Take for example the functions [`renderItems`](https://github.com/calaldees/frameworks_and_languages_module/blob/0f55f66639768032a3f0c0d795e6517ca52f0a11/example_client/index.html#L402-L418) and `render_items`:

``` javascript
402. function renderItems(data) {
403.     const $item_list = document.querySelector(`[data-page="items"] ul`);
404.     const new_item_element = () => document.querySelector(`[data-page="items"] li`).cloneNode(true);
405. 
406.     for (let item_data of data) {
407.         const $new_item_element = new_item_element();
408.         $item_list.appendChild($new_item_element);
409.         renderDataToTemplate(item_data, $new_item_element, renderItemListFieldLookup);
410.         attachDeleteAction($new_item_element);
411.     }
412. }
413. function render_items(params) {
414.     fetch(`${urlAPI}/items?${new URLSearchParams(params).toString()}`)
415.         .then(response => response.json())
416.         .then(renderItems)
417.         .catch(err => console.error(err));
418. }
```

The DOM is directly manipulated to manage state, for instance the `document.querySelector` may not be performative on large trees. The DOM is a hierarchical tree structure, the `document.querySelector` function will traverse the entire tree to find the element. In a commercial setting, this way of rendering the fetched data and DOM is not scalable or performant, moreover, as the application grows teams will struggle to test and refactor due to the increasing complexity. The list is returned in full, some clients devices may suffer slower render times as the large list is rendered in full, due to the iterative and linear nature of the loop.

### Issue 3

The way the server handles lat / lon is completely wrong. haversine/formula or idealy a package should be used.

### Recommendation

The existing implementation hand-rolls various features such as decoding and parsing HTTP requests, that are already implemented in frameworks. Jamming code together so that it works is not a scalable solution, it's not time efficient to develop custom functionality that is already available in frameworks. Frameworks are designed to provide a higher level of abstraction, React state management [@StateSnapshotReact2024] for example would be better than the direct DOM manipulating being used, React's declarative approach is used to describe what the UI should look like, and React handles the DOM manipulation for us.

## Server Framework Features

Server Framework: Gin [@Documentation2022]

### Middleware

Middleware is an intermediary layer that is used to provide modular pre- or post-processing of data that is incoming/outgoing from an application route, whilst maintaining the core functionality of the routing function.

Feature Reference:

-   **Feature Name**: `JSONMiddleware` \
-   **Located in**: `server/main.go` \
-   **Source Code**: [Link to
    Function](https://github.com/jpinn97/frameworks_and_languages_module/blob/b4f100c7aaab889d54233723247817b870699c80/server/main.go#L44-L149) \
-   **Feature Documentation**: [Link to Feature](https://gin-gonic.com/docs/examples/custom-middleware/)

``` Gin
191 r.POST("/item", JSONMiddleware(), PostItemHandler)
``` 
[@UsingMiddleware2022]

When a client POSTs to the `/item` route, the `JSONMiddleware` function is called before the `PostItemHandler` function. 
  
``` Gin
1.  func JSONMiddleware() gin.HandlerFunc {
2.      return func(c *gin.Context) {
3.          // Read the request body and store it in a byte slice.
4.          body, err := c.GetRawData()
5.          if err != nil {
6.              c.JSON(400, gin.H{"error": err.Error()})
7.              c.Abort()
8.              return
9.          }
10. 
11.         // Unmarshal the JSON into itemMiddleware
12.         var customItem interface{}
13.         if err := json.Unmarshal(body, &customItem); err != nil {
14.             c.JSON(400, gin.H{"error": err.Error()})
15.             c.Abort()
16.             return
17.         }
18. 
19.         if m, ok := customItem.(map[string]interface{}); ok {
20.             keywordsValue, exists := m["keywords"]
21.             if !exists {
22.                 // 'Keywords' field is not present, handle accordingly or skip it
23.             } else {
24.                 switch keywords := keywordsValue.(type) {
25.                 case string:
26.                     // Handle the case where 'Keywords' is a string
27.                     // Split the string by comma and store in a map
28.                     keywordsList := strings.Split(keywords, ",")
29.                     keywordMap := make(map[string]struct{})
30.                     for _, keyword := range keywordsList {
31.                         keywordMap[keyword] = struct{}{}
32.                     }
33.                     m["keywords"] = keywordMap
34.                 case []interface{}:
35.                     // Handle the case where 'Keywords' is a slice of interfaces
36.                     // Iterate through the elements and process them as needed.
37.                     keywordMap := make(map[string]struct{})
38.                     for _, val := range keywords {
39.                         if keyword, ok := val.(string); ok {
40.                             // Add the string value to the map
41.                             keywordMap[keyword] = struct{}{}
42.                         }
43.                     }
44.                     m["keywords"] = keywordMap
45.                 default:
46.                     c.JSON(400, gin.H{"error": "Invalid 'Keywords' field type"})
47.                     c.Abort()
48.                     return
49. 
...
1.   
2.          // Set the request body to the updated JSON data.
3.          c.Request.Body = io.NopCloser(bytes.NewReader(updatedBody))
4.   
5.          // Call the next handler.
6.          c.Next()
7.      }
8.   }
```

The `JSONMiddleware` function, implemented from the Gin framework [@CustomMiddleware2022], is used to pre-process the incoming request body, perform validation and transformation of keywords and other field values. The data is modified to the correct format that the `PostItemHandler` function and server expects, it then updates the body with the new bytes. The `PostItemHandler` function is then called, and the request body is parsed, none the wiser of the middleware modifications.

This encapsulates the core functionality of the `PostItemHandler` function, which is to create and store a new item. Furthermore, error handling is done by the middleware, which prevents propagation of malformed data entering deeper into the application. Finally, componentization increases the maintainability and testability of the application as changes are isolated to the middleware function.

Gin middleware is preferred over the standard Go `net/http` package:
- Less boilerplate.
- pre-built logging, recovery, and static file serving middleware.
- Less cognitive load, the `net/http` package requires the developer to understand the `http.Handler` interface more deeply.

### Automatic Binding of JSON to custom struct


The `gin.Context` struct is a simplified, and more developer friendly interface to the `net/http` package. It provides a number of methods for HTTP requests and response handling, data binding, rendering and middleware support.

Feature Reference:

-   **Feature Name**: `gin.Context` Automatic Model/Binding of JSON to custom struct \
-   **Located in**: `server/main.go` 

``` Gin
234. // Call ShouldBindJSON to attempt to bind the received JSON to Item struct.
235. if err := c.ShouldBindJSON(&ReceivedData); err != nil {
236.     c.JSON(http.StatusMethodNotAllowed, gin.H{
237.         "error":       "Invalid input",
238.         "description": "Some input fields may be missing",
239.     })
240.     return
241. }
```

``` Gin
36.  type itemMiddleware struct {
37.      User_ID     string              `json:"user_id" binding:"required"`
38.      Keywords    map[string]struct{} `json:"keywords" binding:"required"`
39.      Description string              `json:"description" binding:"required"`
40.      Image       *string             `json:"image,omitempty"`
41.      Lat         float64             `json:"lat" binding:"required"`
42.      Lon         float64             `json:"lon" binding:"required"`
43.  }
```

The `gin.Context` allows automatic binding and validation of JSON data to a custom struct, Gin provides the additional `binding` tag option to the struct fields [@BindFormdataRequest2022]. This allows the developer to specify the required fields, and the `ShouldBindJSON` [@ModelBindingValidation2022] function will return an error if the required fields are missing. This saves development time, as Go requires significantly more boilerplate to achieve the same functionality through unmarshaling and manual validation.

### Built-in Rendering

-   **Feature Name**: `c.Data` \
-   **Located in**: `server/main.go` \
-   **Source Code**: [Link to
    Function](https://github.com/jpinn97/frameworks_and_languages_module/blob/b4f100c7aaab889d54233723247817b870699c80/server/main.go#L221) \
-   **Feature Documentation**: [Link to Feature](https://gin-gonic.com/docs/examples/html-rendering/)

Gin's c.Data method is a built-in rendering feature for sending raw data as an HTTP response. It allows setting custom Content-Type headers and directly writing byte data to the response body, useful for various content types including HTML.

``` Gin
220.	// Write README.md to response.
221.	c.Data(http.StatusOK, "text/html; charset=utf-8", readmeBytes)
```

This feature streamlines sending custom content types, like HTML, without manual data writing and header management. It simplifies response generation via an API, enhances flexibility, and is beneficial when serving non-JSON content, such as images or HTML. This allows us to serve the README.md on Github, and statically at the root of the server as HTML. Moreover, this feature works for other data types such as JSON, XML, YAML, and Protobuf which provides additionally extensibility and flexibility.

## Server Language Features

Server Language: Golang (Go) [@DocumentationGoProgramming2023]

### (name of Feature 1)

Go routines

### (name of Feature 2)

(Technical description of the feature - 40ish words) (A code block
snippet example demonstrating the feature) (Explain the
problem-this-is-solving/why/benefits/problems - 40ish words) (Provide
reference urls to your sources of information about the feature -
required)

## Client Framework Features

### (name of Feature 1)

(Technical description of the feature - 40ish words) (A code block
snippet example demonstrating the feature) (Explain the
problem-this-is-solving/why/benefits/problems - 40ish words) (Provide
reference urls to your sources of information about the feature -
required)

### (name of Feature 2)

(Technical description of the feature - 40ish words) (A code block
snippet example demonstrating the feature) (Explain the
problem-this-is-solving/why/benefits/problems - 40ish words) (Provide
reference urls to your sources of information about the feature -
required)

### (name of Feature 3)

(Technical description of the feature - 40ish words) (A code block
snippet example demonstrating the feature) (Explain the
problem-this-is-solving/why/benefits/problems - 40ish words) (Provide
reference urls to your sources of information about the feature -
required)

## Client Language Features

### (name of Feature 1)

(Technical description of the feature - 40ish words) (A code block
snippet example demonstrating the feature) (Explain the
problem-this-is-solving/why/benefits/problems - 40ish words) (Provide
reference urls to your sources of information about the feature -
required)

### (name of Feature 2)

(Technical description of the feature - 40ish words) (A code block
snippet example demonstrating the feature) (Explain the
problem-this-is-solving/why/benefits/problems - 40ish words) (Provide
reference urls to your sources of information about the feature -
required)

## Conclusions

(justify why frameworks are recommended - 120ish words) (justify which
frameworks should be used and why 180ish words)

## Notes

-   Routing is defined in server.py: [Lines
    9-16](https://github.com/calaldees/frameworks_and_languages_module/blob/0cfd7c18081da94854f2a8423b12c39ac136d19a/example_server/app/server.py#L9-L16).
    Thousands of routes in a single file is not scalable. Each route
    requires its own import.
-   CORS seems to be manually embedded in the response here: [Line
    71](https://github.com/calaldees/frameworks_and_languages_module/blob/0cfd7c18081da94854f2a8423b12c39ac136d19a/example_server/app/http_server.py#L71).
-   Middleware is used to build modularality into an application. It's
    used to enable customization and or modification of data incoming
    and outgoing from a route. This enables a routes core functionallity
    to be left intact.
