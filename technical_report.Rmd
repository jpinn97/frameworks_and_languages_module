---
title: "Technical Report"
output:
  pdf_document:
    citation_package: default
  md_document:
    variant: gfm
bibliography: bibliography.bib
csl: harvard-cite-them-right.csl
link-citations: true
---

`r if (knitr::is_html_output()) "# Technical Report"`

The purpose of this report is to evaluate and critique the current
framework-less example server and client prototype, and justify and
describe an implementation that includes frameworks and specific
language features. For a simple CRUD (Create, Read, Update, Delete)
Single Page Application (SPA), the usage of frameworks and specific
languages are a necessity for the development of a commercial
application.

Building from scratch may offer complete control over every aspect of
the application if our application was highly unique, but we needn't
reinvent the wheel. Well-established frameworks generally have large
communities, and thus have a wealth of resources, documentation, and
support in addition to thoroughly tested and community driven features.
Which will enable us to develop faster, and maintain our application
more easily over the long term.

## Critique of Server/Client prototype

### Overview

Commercial applications typically require a server to be scalable,
maintainable, and optimized for performance. Hand-rolling solutions
commonly found in frameworks can lead to challenges in development as
application complexity grows, which occurs as new features are added and
extended to improve customer experience.

This stacks up technical debt, it's easier to hire developers who are
familiar with frameworks than it's to hire and train developers with a
custom in-house solution.

### Issue 1

The server is not scalable or capable of asynchronous or concurrent
operations.

Function Reference:

-   **Function Name**: `serve_app`
-   **Located in**: `http_server.py`
-   **Source Code**: [Link to
    Function](https://github.com/calaldees/frameworks_and_languages_module/blob/f396251252434a5a37f29d1ec684ac31d4644bbb/example_server/app/http_server.py#L99-L134)

``` python
99 . def serve_app(func_app, port, host=''):
100.    with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
101.        s.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
102.        s.bind((host, port))
103.        while True:
104.             s.listen()
105.            try:
106.                conn, addr = s.accept()
107.            except KeyboardInterrupt as ex:
108.                break
109.            with conn:
```

The function serve_app is used to listen for incoming connections, and
handle them. On line 104, the function `s.listen()` is called, which
will block the thread until a connection is made. This means that the server will not be able to handle any other requests until the current request is completed. 
Furthermore, according to [@am_i_helpfulAnswerWhatBacklog2016] and [@SocketLowlevelNetworking], the backlog size is influenced by the operating system (OS)'s SOMAXCONN, Linux is currently set to 4096 [@NetIncreaseSOMAXCONN], the large buffer of unaccepted connections will cause clients to experience latency if the server is under heavy load due to the sequential handling of requests.

``` python
110. #log.debug(f'Connected by ')
111. #while True:
112.     data = conn.recv(65535)  # If the request does not come though in a single recv/packet then this server will fail and will not composit multiple TCP packets. Sometimes the head and the body are sent in sequential packets. This happens when the system switches task under load.
113.     #if not data: break
114.     try:
115.         request = parse_request(data)
116.     except InvalidHTTPRequest as ex:
117.         log.exception("InvalidHTTPRequest")
118.         continue
119. 
120.     # HACK: If we don't have a complete message - try to botch another recv - I feel dirty doing this 
121.     # This probably wont work because utf8 decoded data will have a different content length 
122.     # This needs more testing
123.     while int(request.get('content-length', 0)) > len(request['body']):
124.         request['body'] += conn.recv(65535).decode('utf8')
```

The function struggles with handling TCP data that arrives in fragments, attempting to make additional recv calls to gather more data. It relies on the content-length header to decide if further recv calls are necessary. However, this approach fails to properly decode non-UTF-8 data, such as binary image data. Additionally, UTF-8's variable-width encoding has multi-byte characters such as "C3 A9" occupying two bytes and is "Ã©" [@UTF82023] that might be split across different packets which when decoded could form an illegal sequence, leading to a UnicodeDecodeError [@UnicodeDecodeErrorPythonWiki]. As indicated in the comments on line 121, the actual body size can become larger than what the content-length suggests as data size increases once decoded. The server will drop the connection if the content-length is exceeded, which will result in a broken image or data corruption.

Finally, the function has no error handling in the case of timeouts or resource exhaustion.

### (name of Issue 2)

File Reference:
- **File Name**: `index.html`
- **Description**: The example client.
- **Source Code**: [Link to File](https://github.com/calaldees/frameworks_and_languages_module/blob/0f55f66639768032a3f0c0d795e6517ca52f0a11/example_client/index.html)

A number of functions such as `renderItems`, `renderDataToTemplate`, `attachDeleteAction`, and `clear_node` directly manipulate the DOM. This is generally not recommended to do in such vast amounts. Especially when the functions are tightly coupled.

Take for example the functions [`renderItems`](https://github.com/calaldees/frameworks_and_languages_module/blob/0f55f66639768032a3f0c0d795e6517ca52f0a11/example_client/index.html#L402-L418) and `render_items`:

``` javascript
402. function renderItems(data) {
403.     const $item_list = document.querySelector(`[data-page="items"] ul`);
404.     const new_item_element = () => document.querySelector(`[data-page="items"] li`).cloneNode(true);
405. 
406.     for (let item_data of data) {
407.         const $new_item_element = new_item_element();
408.         $item_list.appendChild($new_item_element);
409.         renderDataToTemplate(item_data, $new_item_element, renderItemListFieldLookup);
410.         attachDeleteAction($new_item_element);
411.     }
412. }
413. function render_items(params) {
414.     fetch(`${urlAPI}/items?${new URLSearchParams(params).toString()}`)
415.         .then(response => response.json())
416.         .then(renderItems)
417.         .catch(err => console.error(err));
418. }
```
The DOM is directly manipulated to manage state, for instance the `document.querySelector` may not be performative on large trees. The DOM is a hierachical tree structure, the `document.querySelector` function will traverse the entire tree to find the element. In a commercial setting, this way of rendering the fetched data and DOM is not scalable or performant, moreoever, as the application grows teams will struggle to test and refactor due to the increasing complexity. The list is returned in full, some clients devices may suffer slower render times as the large list is rendered in full, due to the iterative and linear nature of the loop.

### Recommendation

(why the existing implementation should not be used - 40ish words)
(suggested direction - frameworks 40ish words)

- timeout settimeout() or framework?

server

client



## Server Framework Features

### (name of Feature 1)

(Technical description of the feature - 40ish words) (A code block
snippet example demonstrating the feature) (Explain the
problem-this-is-solving/why/benefits/problems - 40ish words) (Provide
reference urls to your sources of information about the feature -
required)

### (name of Feature 2)

(Technical description of the feature - 40ish words) (A code block
snippet example demonstrating the feature) (Explain the
problem-this-is-solving/why/benefits/problems - 40ish words) (Provide
reference urls to your sources of information about the feature -
required)

### (name of Feature 3)

(Technical description of the feature - 40ish words) (A code block
snippet example demonstrating the feature) (Explain the
problem-this-is-solving/why/benefits/problems - 40ish words) (Provide
reference urls to your sources of information about the feature -
required)

## Server Language Features

### (name of Feature 1)

(Technical description of the feature - 40ish words) (A code block
snippet example demonstrating the feature) (Explain the
problem-this-is-solving/why/benefits/problems - 40ish words) (Provide
reference urls to your sources of information about the feature -
required)

### (name of Feature 2)

(Technical description of the feature - 40ish words) (A code block
snippet example demonstrating the feature) (Explain the
problem-this-is-solving/why/benefits/problems - 40ish words) (Provide
reference urls to your sources of information about the feature -
required)

## Client Framework Features

### (name of Feature 1)

(Technical description of the feature - 40ish words) (A code block
snippet example demonstrating the feature) (Explain the
problem-this-is-solving/why/benefits/problems - 40ish words) (Provide
reference urls to your sources of information about the feature -
required)

### (name of Feature 2)

(Technical description of the feature - 40ish words) (A code block
snippet example demonstrating the feature) (Explain the
problem-this-is-solving/why/benefits/problems - 40ish words) (Provide
reference urls to your sources of information about the feature -
required)

### (name of Feature 3)

(Technical description of the feature - 40ish words) (A code block
snippet example demonstrating the feature) (Explain the
problem-this-is-solving/why/benefits/problems - 40ish words) (Provide
reference urls to your sources of information about the feature -
required)

## Client Language Features

### (name of Feature 1)

(Technical description of the feature - 40ish words) (A code block
snippet example demonstrating the feature) (Explain the
problem-this-is-solving/why/benefits/problems - 40ish words) (Provide
reference urls to your sources of information about the feature -
required)

### (name of Feature 2)

(Technical description of the feature - 40ish words) (A code block
snippet example demonstrating the feature) (Explain the
problem-this-is-solving/why/benefits/problems - 40ish words) (Provide
reference urls to your sources of information about the feature -
required)

## Conclusions

(justify why frameworks are recommended - 120ish words) (justify which
frameworks should be used and why 180ish words)

## Notes

-   Routing is defined in server.py: [Lines
    9-16](https://github.com/calaldees/frameworks_and_languages_module/blob/0cfd7c18081da94854f2a8423b12c39ac136d19a/example_server/app/server.py#L9-L16).
    Thousands of routes in a single file is not scalable. Each route
    requires its own import.
-   CORS seems to be manually embedded in the response here: [Line
    71](https://github.com/calaldees/frameworks_and_languages_module/blob/0cfd7c18081da94854f2a8423b12c39ac136d19a/example_server/app/http_server.py#L71).
-   Middleware is used to build modularality into an application. It's
    used to enable customization and or modification of data incoming
    and outgoing from a route. This enables a routes core functionallity
    to be left intact.
